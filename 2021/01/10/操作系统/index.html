<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.0.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/rocket_132px_1222543_easyicon.net.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/rocket_132px_1222543_easyicon.net.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/rocket_132px_1222543_easyicon.net.png">
  <link rel="mask-icon" href="/images/rocket_1222543_easyicon.net.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/pink/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"kebabshellgithub.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.11.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":80,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"slideLeftIn","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="总结">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统">
<meta property="og:url" content="https://kebabshellgithub.github.io/2021/01/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="秋早亦朝">
<meta property="og:description" content="总结">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-01-10T16:24:23.000Z">
<meta property="article:modified_time" content="2023-04-06T11:06:55.042Z">
<meta property="article:author" content="KebabShell">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://kebabshellgithub.github.io/2021/01/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://kebabshellgithub.github.io/2021/01/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","path":"2021/01/10/操作系统/","title":"操作系统"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>操作系统 | 秋早亦朝</title>
  

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?5e2684a539c5d87042f60cb2b8d78c36"></script>




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="秋早亦朝" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">秋早亦朝</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Kurosak1</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.</span> <span class="nav-text">操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81"><span class="nav-number">1.1.</span> <span class="nav-text">用户态和内核态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%99%B7%E5%85%A5%E5%86%85%E6%A0%B8%E6%80%81"><span class="nav-number">1.2.</span> <span class="nav-text">陷入内核态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.3.</span> <span class="nav-text">进程与线程的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.4.</span> <span class="nav-text">为什么需要线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8C%E4%B8%80%E8%BF%9B%E7%A8%8B%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E4%B8%8E%E7%8B%AC%E5%8D%A0%E7%9A%84%E8%B5%84%E6%BA%90"><span class="nav-number">1.5.</span> <span class="nav-text">同一进程中的线程共享与独占的资源</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%9C%E4%B8%9A%E3%80%81%E7%AE%A1%E7%A8%8B"><span class="nav-number">1.6.</span> <span class="nav-text">作业、管程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81"><span class="nav-number">1.7.</span> <span class="nav-text">进程的三种基本状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux-%E8%BF%9B%E7%A8%8B%E7%9A%84-5-%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="nav-number">1.8.</span> <span class="nav-text">Linux 进程的 5 种状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">1.9.</span> <span class="nav-text">进程调度算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%EF%BC%88%E5%90%8C%E6%AD%A5%EF%BC%89%E6%96%B9%E5%BC%8F%EF%BC%88IPC%EF%BC%89"><span class="nav-number">1.10.</span> <span class="nav-text">进程通信（同步）方式（IPC）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B4%E7%95%8C%E8%B5%84%E6%BA%90%E5%92%8C%E4%B8%B4%E7%95%8C%E5%8C%BA%E3%80%81%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5"><span class="nav-number">1.10.1.</span> <span class="nav-text">临界资源和临界区、互斥与同步</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="nav-number">1.11.</span> <span class="nav-text">死锁产生的四个必要条件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E9%81%BF%E5%85%8D"><span class="nav-number">1.12.</span> <span class="nav-text">死锁的避免</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%EF%BC%88%E5%90%8C%E6%AD%A5%EF%BC%89%E6%96%B9%E5%BC%8F"><span class="nav-number">1.13.</span> <span class="nav-text">线程通信（同步）方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%8A%96%E5%8A%A8"><span class="nav-number">1.14.</span> <span class="nav-text">内存抖动</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">1.15.</span> <span class="nav-text">物理内存管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">1.16.</span> <span class="nav-text">虚拟内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux%E8%99%9A%E5%AD%98"><span class="nav-number">1.16.1.</span> <span class="nav-text">Linux虚存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="nav-number">1.16.1.1.</span> <span class="nav-text">用户空间内存分配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="nav-number">1.16.1.2.</span> <span class="nav-text">内核空间内存分配</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.17.</span> <span class="nav-text">文件系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#I-x2F-O"><span class="nav-number">1.18.</span> <span class="nav-text">I&#x2F;O</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="KebabShell"
      src="/images/hexo.jpg">
  <p class="site-author-name" itemprop="name">KebabShell</p>
  <div class="site-description" itemprop="description">纯个人记录</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">72</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">34</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/KebabShellGitHub" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;KebabShellGitHub" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:kebabshell@163.com" title="E-Mail → mailto:kebabshell@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/2837329130" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;2837329130" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kebabshellgithub.github.io/2021/01/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hexo.jpg">
      <meta itemprop="name" content="KebabShell">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="秋早亦朝">
      <meta itemprop="description" content="纯个人记录">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="操作系统 | 秋早亦朝">
      <meta itemprop="description" content="总结">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          操作系统
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-10 16:24:23" itemprop="dateCreated datePublished" datetime="2021-01-10T16:24:23+00:00">2021-01-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
</div>

            <div class="post-description">总结</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><blockquote>
<p><a target="_blank" rel="noopener" href="https://imageslr.com/2020/07/08/tech-interview.html">参考</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000022506020">参考</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzkwOTE2OTY1Nw==&mid=2247486893&idx=1&sn=8295c8a87137ccc7fa5eebcbca350b81&source=41#wechat_redirect">参考</a></p>
</blockquote>
<h2 id="用户态和内核态"><a href="#用户态和内核态" class="headerlink" title="用户态和内核态"></a>用户态和内核态</h2><p>最简单的运行程序的方式是“直接执行”，即直接在 CPU 上执行任意程序。直接执行的问题是：</p>
<ol>
<li>无法限制</li>
<li>无法进程调度</li>
</ol>
<p>因此引入用户态和内核态和两种模式。用户态无法执行受限操作，如 I&#x2F;O 请求，执行这些操作会引发异常。内核态只能由操作系统运行，可以执行特权操作。用户程序通过<strong>系统调用</strong>执行这些特权操作。OS 执行前会判断进程是否有<strong>权限</strong>执行相应的指令</p>
<h2 id="陷入内核态"><a href="#陷入内核态" class="headerlink" title="陷入内核态"></a>陷入内核态</h2><p>系统调用（trap）、中断（interrupt）和异常（exception）</p>
<ul>
<li>C 访问空指针会陷入内核态，访问指针相当于访问一个虚拟地址，直接映射到物理内存</li>
</ul>
<h2 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h2><ul>
<li>进程是一个<strong>拥有资源</strong>和执行任务的单元体。进程拥有的资源包括：内存空间中的代码、数据等；I&#x2F;O 资源；文件；处理机等。</li>
<li>线程是一个执行任务的单元体。线程<strong>只拥有处理机</strong>，线程之间<strong>共享进程的资源</strong>，如内存、I&#x2F;O 等。</li>
</ul>
<h2 id="为什么需要线程"><a href="#为什么需要线程" class="headerlink" title="为什么需要线程"></a>为什么需要线程</h2><ul>
<li>只切换必需的、与处理机相关的信息，减少开销</li>
<li>当<strong>上下文切换</strong>的时候，正在运行的线程会将寄存器的状态保存到 TCB（Thread Control Block）里（进程是 PCB，Process Control Block），然后恢复另一个线程的上下文</li>
<li>问题就是并发，共享空间，一个线程出错，整个进程都会结束（使用多进程解决）</li>
</ul>
<h2 id="同一进程中的线程共享与独占的资源"><a href="#同一进程中的线程共享与独占的资源" class="headerlink" title="同一进程中的线程共享与独占的资源"></a>同一进程中的线程共享与独占的资源</h2><ul>
<li>共享<ul>
<li>内存空间<ul>
<li>代码</li>
<li>公共数据（全局变量、静态变量）</li>
<li>堆</li>
</ul>
</li>
<li>文件描述符</li>
<li>信号处理器</li>
<li>进程 ID &#x2F; 进程组 ID</li>
<li>。。。</li>
</ul>
</li>
<li>独占<ul>
<li>线程 ID</li>
<li>栈（函数调用）</li>
<li>错误返回码</li>
<li>信号屏蔽码</li>
</ul>
</li>
</ul>
<h2 id="作业、管程"><a href="#作业、管程" class="headerlink" title="作业、管程"></a>作业、管程</h2><ul>
<li>作业：用户在一次解题或一个事务处理过程中<strong>要求计算机系统所做工作的集合</strong>。它包括用户程序、所需要的数据及控制命令等。作业时由<strong>一系列有序的步骤</strong>组成的</li>
<li>管程：是定义了一个数据结构和在该数据结构上能为并发进程所执行的一组操作。这些操作能同步进程和改变管程中的数据。它是一种<strong>进程同步机制</strong>。在结构上类似于面向对象中的类。在功能上和信号量和p，v操作类似。可以更方便的<strong>管理系统的临界资源</strong></li>
</ul>
<h2 id="进程的三种基本状态"><a href="#进程的三种基本状态" class="headerlink" title="进程的三种基本状态"></a>进程的三种基本状态</h2><ul>
<li>就绪：进程已获得除处理机以外的所需资源，等待分配处理机资源</li>
<li>执行：进程正在占用处理机资源执行</li>
<li>阻塞：进程等待某种条件，在条件满足之前无法执行。如发起了 I&#x2F;O 系统调用，会被阻塞，等待 I&#x2F;O 中断发生</li>
<li>注意挂起和阻塞的区别<ul>
<li>“挂起”是指将暂不执行的进程换出到外存，节省内存空间<ul>
<li>挂起就绪状态：进程在外存中，但是只要被载入内存就可以执行</li>
<li>挂起阻塞状态：进程在外存中并<strong>等待一个事件</strong>，即使被载入内存（激活）也<strong>无法运行</strong></li>
</ul>
</li>
</ul>
</li>
<li>Linux 下的阻塞状态可分为 3 种：暂停、浅睡眠、深睡眠<ul>
<li>若不需要等待资源，则切换为“暂停”；若需要等待资源，切换为“睡眠”；如果睡眠状态能被信号唤醒，则是“浅睡眠”，否则是“深睡眠”</li>
</ul>
</li>
</ul>
<h2 id="Linux-进程的-5-种状态"><a href="#Linux-进程的-5-种状态" class="headerlink" title="Linux 进程的 5 种状态"></a>Linux 进程的 5 种状态</h2><h2 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h2><ul>
<li>注意饥饿问题、僵尸进程（僵尸进程、孤儿进程、守护进程）</li>
<li>批处理系统<ul>
<li>先来先服务 FCFS、最短作业优先 SJF、最短剩余时间优先 SRTN、最高响应比优先 HRRN</li>
</ul>
</li>
<li>交互系统（分时系统）<ul>
<li>时间片轮转 RR、优先级调度 Priority、多级反馈队列 MFQ、彩票法、公平分享法</li>
</ul>
</li>
<li>实时系统<ul>
<li>最早截止时间优先算法</li>
</ul>
</li>
<li>僵尸进程、孤儿进程、守护进程<ul>
<li><a target="_blank" rel="noopener" href="https://liubigbin.github.io/2016/03/11/Linux-%E4%B9%8B%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E3%80%81%E5%83%B5%E6%AD%BB%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B/">参考</a></li>
<li>僵尸进程：停止运行</li>
<li>孤儿进程：正在运行</li>
<li>守护进程：正在运行</li>
</ul>
</li>
</ul>
<h2 id="进程通信（同步）方式（IPC）"><a href="#进程通信（同步）方式（IPC）" class="headerlink" title="进程通信（同步）方式（IPC）"></a>进程通信（同步）方式（IPC）</h2><ul>
<li><p>信号</p>
</li>
<li><p>管道</p>
<ul>
<li>匿名管道和命名管道<ul>
<li>匿名管道（pipe）<ul>
<li>只能用在亲缘进程中，管道文件信息保存在内存里</li>
<li>本质是一个伪文件(实为内核缓冲区)，由两个文件描述符引用，一个表示读端，一个表示写端</li>
<li>下游进程或者上游进程需要等另一方释放锁后才能操作管道。管道就相当于一个文件，同一时刻只能有一个进程访问</li>
<li>数据自己读不能自己写</li>
<li>管道不再被任何进程使用时，自动消失，生命周期随进程的结束结束</li>
</ul>
</li>
<li>命名管道（FIFO）<ul>
<li>以FIFO的文件形式存储于文件系统中，因此，可用于没有亲缘的进程间</li>
<li>也是通过<strong>内核缓冲区</strong>来实现数据传输</li>
<li>建立命名管道时，会在磁盘中创建一个索引节点，命名管道的名字就相当于索引节点的文件名</li>
<li>当不再被任何进程使用时，命名管道在内存中释放，但磁盘节点仍然存在</li>
</ul>
</li>
</ul>
</li>
<li>管道是由内核管理的一个缓冲区，缓冲区被设计成为环形的数据结构，以便管道可以被循环利用（循环队列）</li>
</ul>
</li>
<li><p>信号量 Semaphore</p>
<ul>
<li>S 表示可用资源的数量</li>
<li>P(S) 即 down<ul>
<li><strong>请求</strong>分配一个单位资源，减少信号量 S 的数值，如果 S 为 0，则挂起进程</li>
</ul>
</li>
<li>V(S) 即 up<ul>
<li><strong>释放</strong>资源，若S&gt;0，唤醒等待队列中的一个进程，增加信号量 S 的数值，</li>
</ul>
</li>
<li>如果信号量只有二进制的 0 或 1，称为<strong>二进制信号量</strong>（binary semaphore）。二进制信号量可以用来实现一个<strong>互斥锁（Mutex）</strong></li>
</ul>
</li>
<li><p>共享内存</p>
<ul>
<li>管道和消息队列，需要在内核和用户空间进行四次的数据拷贝（读输入文件、写到管道；读管道、写到输出文件），而共享内存则只拷贝两次（一次从输入文件到共享内存区，另一次从共享内存到输出文件）</li>
<li>缺点是存在并发问题</li>
</ul>
</li>
<li><p>消息队列</p>
<ul>
<li>接收者必须轮询消息队列，才能收到最近的消息</li>
<li>与管道相比，消息队列提供了有格式的数据，但消息队列仍然有大小限制</li>
</ul>
</li>
<li><p>套接字</p>
<ul>
<li>不同的计算机的进程之间通过 socket 通信，也可用于同一台计算机的不同进程</li>
<li>主机地址与端口号</li>
<li>网络层</li>
</ul>
</li>
<li><p>锁</p>
<ul>
<li>互斥锁、读写锁、自旋锁、条件锁</li>
<li>互斥锁的开销主要体现在线程的重新调度和上下文切换上，获取锁的开销是比较大的。因此 mutex 适用于线程持有锁时间比较长的场景</li>
</ul>
</li>
</ul>
<h3 id="临界资源和临界区、互斥与同步"><a href="#临界资源和临界区、互斥与同步" class="headerlink" title="临界资源和临界区、互斥与同步"></a>临界资源和临界区、互斥与同步</h3><ul>
<li>临界资源：一次仅允许一个进程使用的共享资源，也就是互斥资源</li>
<li>临界区：程序中访问临界资源的那段代码，也称危险区、敏感区</li>
<li>互斥：多个程序片段，同一时刻仅有一个能进入临界区</li>
<li>同步：若干程序片断运行必须严格按照规定的某种先后次序来运行。同步是一种更复杂的互斥：互斥不会限制程序对资源的访问顺序，即访问是无序的；而同步必须要按照某种次序来运行</li>
<li>常见的同步问题<ul>
<li>生产者与消费者问题<ul>
<li>生产者和消费者共享固定大小的缓冲区，生产者向缓冲区写入数据，消费者从缓冲区读出数据，生产者不能在缓冲区满时加入数据，消费者也不能在缓冲区空时消耗数据</li>
<li>这里如果直接使用操作系统提供的 sleep() 和 wakeup()，可能发生死锁，原因在于：「判断是否要休眠（缓冲区空&#x2F;满）」和「执行 sleep()」不是一个原子操作，有可能在执行 sleep() 之前被切换到另一个程序，导致 wakeup() 信号丢失，最后两者都进入休眠</li>
<li>使用<strong>信号量</strong>可以解决上述问题</li>
<li>在多个生产者和消费者的情况下，有可能出现两个或以上的进程同时读或写同一个缓冲区槽的情况，因此再用一个<strong>二值信号量 mutex</strong> 实现一个锁</li>
</ul>
</li>
<li>读者写者问题<ul>
<li>允许多个进程同时读数据库</li>
<li>有进程在读数据库的时候，不允许写数据库</li>
<li>如果有一个进程正在写数据库，则不允许其他任何进程访问数据库</li>
</ul>
</li>
<li>浴室洗澡问题<ul>
<li>一个浴室，当有一个女生在浴室里，其他女生可以进入，但是男生不行，反之亦然</li>
</ul>
</li>
<li>哲学家就餐问题<ul>
<li>假设有五位哲学家围坐在一张圆形餐桌旁，吃饭或者思考。每位哲学家之间各有一根筷子，哲学家必须用两根筷子吃东西。他们只能使用自己左右手边的那两根筷子</li>
<li>可能有死锁的写法：每个哲学家都拿着左边的筷子，永远都在等右边的筷子</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="死锁产生的四个必要条件"><a href="#死锁产生的四个必要条件" class="headerlink" title="死锁产生的四个必要条件"></a>死锁产生的四个必要条件</h2><ul>
<li><strong>互斥</strong>条件</li>
<li><strong>占有且等待</strong>条件：线程占有已经分配给它们的资源（如锁）并且等待其他的资源（也就是说不会<em>主动</em>释放）</li>
<li><strong>不可抢占</strong>条件（也就是说不会<em>被动</em>释放）</li>
<li><strong>环路等待</strong>条件：每个进程都在等待下一个进程占有的资源</li>
</ul>
<h2 id="死锁的避免"><a href="#死锁的避免" class="headerlink" title="死锁的避免"></a>死锁的避免</h2><p>破坏上面四个条件任意一个，但很难，所以</p>
<ul>
<li><strong>银行家算法</strong>：允许系统中同时存在四个必要条件，但是每当进程提出资源申请时，系统要分析满足该资源请求后，系统是否会发生死锁，若不会发生则实施分配，否则拒绝分配，即<ul>
<li>通过先 <strong>试探</strong> 分配给该进程资源，然后通过安全性算法判断分配后的系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待</li>
</ul>
</li>
</ul>
<h2 id="线程通信（同步）方式"><a href="#线程通信（同步）方式" class="headerlink" title="线程通信（同步）方式"></a>线程通信（同步）方式</h2><ul>
<li>信号，使用方法和进程几乎一样，但是是另一套相似的API，不可以互换</li>
<li>信号量，和进程类似，功能和互斥锁基本一样</li>
<li>互斥锁，保护临界资源</li>
<li>控制变量，常和互斥锁配合使用，控制线程执行的先后。暂时挂起线程还锁，解决线程为获得数据等待其他线程，导致长时间占用锁</li>
</ul>
<h2 id="内存抖动"><a href="#内存抖动" class="headerlink" title="内存抖动"></a>内存抖动</h2><p>指内存频繁地分配和回收，占用了大量CPU时间</p>
<h2 id="物理内存管理"><a href="#物理内存管理" class="headerlink" title="物理内存管理"></a>物理内存管理</h2><ul>
<li>内部碎片和外部碎片<ul>
<li>内部碎片是固定分区法产生的，指<strong>被占用分区上</strong>未被利用的空间，由于该分区被占用，因此无法被分配使用</li>
<li>外部碎片是动态分区法产生的，指被占用分区<strong>之间的小空间</strong>，虽然可以被使用，但是<strong>由于太小而无法被分配</strong></li>
<li>解决：<ul>
<li><strong>页面管理算法（Linux）</strong><ul>
<li>Buddy（伙伴）分配算法<ul>
<li>把相同大小的页框块用链表串起来</li>
<li>所有的空闲页框分组为11个块链表，每个块链表分别包含大小为1，2，4，8，16，32，64，128，256，512和1024个连续页框的页框块。最大可以申请1024个连续页框，对应4MB大小的连续内存</li>
<li>因为任何正整数都可以由 2^n 的和组成，所以总能找到合适大小的内存块分配出去，减少了外部碎片产生</li>
</ul>
</li>
<li>slab 分配器<ul>
<li>通过将内存按使用对象不同再划分成不同大小的空间，应用于内核对象的缓存</li>
<li>内核中有大量的小对象，对于每个内核中的相同类型的对象，如：task_struct、file_struct 等需要重复使用的小型内核数据对象，都会有个 slab 缓存池，缓存住大量常用的「已经初始化」的对象，每当要申请这种类型的对象时，就从缓存池的slab 列表中分配一个出去；而当要释放时，将其重新保存在该列表中，而不是直接返回给伙伴系统，从而避免内部碎片，同时也大大提高了内存分配性能</li>
<li>slab 内存分配器是对伙伴分配算法的补充</li>
<li>slab 高速缓存分为两大类，<strong>通用高速缓存</strong>和<strong>专用高速缓存</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>固定分区法（等长、不等长）</li>
<li>动态分区法</li>
<li><strong>页式</strong>内存管理<ul>
<li>把<strong>固定分区</strong>面积缩小，一个进程可使用多个分区；进程被分割成若干块，<strong>装入内存中的几个分区中，物理上无需相连</strong>，逻辑上通过页表关联</li>
</ul>
</li>
<li><strong>段式</strong>内存管理<ul>
<li>按照逻辑意义将<strong>程序</strong>分成若干个段，每个段<strong>独立载入到内存的不同区间</strong>中</li>
<li>缺点：每个段必须<strong>连续、全部</strong>加载到内存中</li>
</ul>
</li>
<li><strong>段页式</strong>内存管理<ul>
<li>先把<strong>程序</strong>按照逻辑意义<strong>分成段</strong>，然后<strong>每个段</strong>再<strong>分成固定大小的页</strong></li>
</ul>
</li>
<li>页面、页框、页表<ul>
<li>页表：每个进程有一个页表，描述该进程每个页面对应的页框号，以及该页面是否已经被载入内存（“在&#x2F;不在”位）</li>
<li>对大内存页表<ul>
<li>多级页表<ul>
<li>时间换空间，节省空间，时间可以用 TLB 来缓解</li>
</ul>
</li>
<li>倒排页表</li>
<li>散列表</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h2><ul>
<li>原先的覆盖、交换技术太垃圾</li>
<li>虚存管理和覆盖技术一样，不是把程序所有内容全部放入内存，但这个操作是<strong>由操作系统完成</strong>，而不是程序员</li>
<li>和交换技术一样，实现进程在内存和外存的交换，但虚存管理做的更好，是只对<strong>进程的部分内容</strong>在内存和外存之间交换</li>
<li>需要有程序局部性（要有时间、空间局部性）<ul>
<li>P23</li>
<li>指程序在执行过程中的一个较短时期，所执行的指令地址和指令的操作数地址，分别局限于一定区域</li>
</ul>
</li>
<li>物理内存分配不连续，虚拟地址空间使用不连续</li>
<li>简略实现<ul>
<li>在系统中为每个程序定义一个虚拟地址空间，虚拟地址空间中的地址都是连续的</li>
<li>虚拟地址空间被分割成多个块，每块称为一个页或者<strong>页面</strong></li>
<li>物理内存被分成和页面大小相同的多个区域，称作<strong>页框</strong></li>
<li>程序加载时，可将任意一个页面放入内存中的任意一个页框</li>
<li>CPU 的硬件负责将虚拟地址映射到物理内存中的地址（页面 -&gt; 页框）</li>
<li>程序的整个地址空间无需全部载入物理内存，还有<strong>部分暂时存储在外存</strong>上，需要时再换入内存</li>
<li>如果程序引用到一部分不在物理内存中的虚拟地址时，会发生<strong>缺页中断</strong>，由操作系统负责将缺失的页面加载入页框中，并重新执行失败的指令</li>
</ul>
</li>
<li>交换分区</li>
<li>转换检测缓冲区（TLB）<ul>
<li>缓冲页表</li>
</ul>
</li>
<li>缺页中断&#x2F;异常<ul>
<li>请求调页和页面置换</li>
<li>页面置换&#x2F;淘汰</li>
<li>目的是减少页面换入换出的次数</li>
<li>局部页面置换算法<ul>
<li>最优页面置换算法<ul>
<li>判断未来，是理想情况，实际中不可能实现</li>
<li>这是评价标准</li>
</ul>
</li>
<li>FIFO</li>
<li>LRU 最近最久未使用<ul>
<li>（算法题：链表 + 哈希表）</li>
</ul>
</li>
<li>第二次机会算法<ul>
<li>FIFO 的改进</li>
</ul>
</li>
<li>时钟页面置换算法（Clock 算法）<ul>
<li>LRU 近似 + 第二次机会置换法的改进</li>
<li>将页面保存在环形链表中，只需要后移队头指针，就相当于是把原来的队头放到队尾了，避免了移动链表节点的开销</li>
</ul>
</li>
<li>LFU 最不常用</li>
<li>Belady 现象：FIFO时，可能会出现分配的物理页面增多，缺页率反而提高</li>
<li>LRU 性能好，但开销大，FIFO 开销小，但会 Belady；还是 Clock 算法折中</li>
</ul>
</li>
<li>全局页面置换算法<ul>
<li>工作集页置换算法</li>
<li>缺页率置换算法</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Linux虚存"><a href="#Linux虚存" class="headerlink" title="Linux虚存"></a>Linux虚存</h3><h4 id="用户空间内存分配"><a href="#用户空间内存分配" class="headerlink" title="用户空间内存分配"></a>用户空间内存分配</h4><ul>
<li>malloc<ul>
<li>当申请小于 128KB 小内存的时， malloc 使用 sbrk 或 brk 分配内存；当申请大于 128KB 的内存时，使用 mmap 函数申请内存</li>
<li>由于 brk&#x2F;sbrk&#x2F;mmap 属于系统调用，cpu 在用户态和内核态之间频繁切换<ul>
<li>解决：malloc 使用的是内存池<ul>
<li><strong>先申请一块大内存</strong>，然后将内存分成不同大小的内存块，然后用户申请内存时，<strong>直接从内存池中</strong>选择一块相近的内存块分配出去</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="内核空间内存分配"><a href="#内核空间内存分配" class="headerlink" title="内核空间内存分配"></a>内核空间内存分配</h4><ul>
<li><p>kmalloc</p>
<ul>
<li>分配的虚拟地址范围在内核空间的直接内存映射区</li>
<li>基于 slab 分配器</li>
<li>按字节为单位虚拟内存，一般用于分配<strong>小块内存</strong>，释放内存对应于 kfree ，可以分配连续的物理内存</li>
</ul>
</li>
<li><p>vmalloc</p>
<ul>
<li>分配的虚拟地址区间，位于 vmalloc_start 与 vmalloc_end 之间的动态内存映射区</li>
<li>（内核页表）</li>
<li>一般用分配<strong>大块内存</strong>，释放内存对应于 vfree，分配的虚拟内存地址连续，物理地址上不一定连续</li>
</ul>
</li>
<li><p>两个再通过 Buddy 分配内存</p>
</li>
</ul>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><ul>
<li>文件块<ul>
<li>卷控制模块、控制块、目录节点会部分加载进内存以提高访问效率</li>
</ul>
</li>
<li>文件表</li>
<li>层次目录结构</li>
<li>路径遍历</li>
<li>种类<ul>
<li>磁盘文件系统：FAT、NTFS、ext2&#x2F;3&#x2F;4…</li>
<li>数据库文件系统</li>
<li>日志文件系统</li>
<li>。。。</li>
</ul>
</li>
<li>虚拟文件系统<ul>
<li>可以说整合了各种文件系统的复杂操作，成为一个虚拟文件系统层，提供了文件系统 API</li>
</ul>
</li>
<li>RAID<ul>
<li>RAID-0：把数据均匀的分布在不同的磁盘上，然后并行访问</li>
<li>RAID-1：写数据时往几个同样的硬盘写同样的数据（可靠性）</li>
<li>RAID-4：0和1结合，用额外的一个盘（Parity Disk）来容错，这个盘会频繁写</li>
<li>RAID-5：把Parity Disk均匀分布在不同的硬盘上</li>
<li>。。。</li>
</ul>
</li>
</ul>
<h2 id="I-x2F-O"><a href="#I-x2F-O" class="headerlink" title="I&#x2F;O"></a>I&#x2F;O</h2><ul>
<li>5 种 I&#x2F;O 模型：阻塞 I&#x2F;O、非阻塞 I&#x2F;O、信号驱动式 I&#x2F;O、I&#x2F;O 多路复用、异步 I&#x2F;O（AIO）</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"># 操作系统</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/01/10/ThreadLocal/" rel="prev" title="ThreadLocal">
                  <i class="fa fa-chevron-left"></i> ThreadLocal
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/03/17/JVM%E5%9F%BA%E7%A1%80/" rel="next" title="JVM 基础">
                  JVM 基础 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">KebabShell</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  <script src="/js/third-party/pace.js"></script>

  





</body>
</html>
