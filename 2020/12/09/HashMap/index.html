<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.0.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/rocket_132px_1222543_easyicon.net.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/rocket_132px_1222543_easyicon.net.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/rocket_132px_1222543_easyicon.net.png">
  <link rel="mask-icon" href="/images/rocket_1222543_easyicon.net.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/pink/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"kebabshellgithub.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.11.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":80,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"slideLeftIn","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="HashMap 源码与总结">
<meta property="og:type" content="article">
<meta property="og:title" content="HashMap">
<meta property="og:url" content="https://kebabshellgithub.github.io/2020/12/09/HashMap/index.html">
<meta property="og:site_name" content="秋早亦朝">
<meta property="og:description" content="HashMap 源码与总结">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-12-09T23:00:46.000Z">
<meta property="article:modified_time" content="2023-04-06T11:06:55.022Z">
<meta property="article:author" content="KebabShell">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="集合">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://kebabshellgithub.github.io/2020/12/09/HashMap/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://kebabshellgithub.github.io/2020/12/09/HashMap/","path":"2020/12/09/HashMap/","title":"HashMap"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>HashMap | 秋早亦朝</title>
  

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?5e2684a539c5d87042f60cb2b8d78c36"></script>




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="秋早亦朝" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">秋早亦朝</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Kurosak1</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%85%E8%AF%86%E7%9A%84%E5%8F%98%E9%87%8F"><span class="nav-number">1.</span> <span class="nav-text">必识的变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#resize"><span class="nav-number">2.</span> <span class="nav-text">resize</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%AE%B9%E5%90%8E%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="nav-number">2.1.</span> <span class="nav-text">扩容后链表元素的位置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#putVal"><span class="nav-number">3.</span> <span class="nav-text">putVal</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%BE%E6%8F%92%E6%B3%95"><span class="nav-number">3.1.</span> <span class="nav-text">尾插法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">4.</span> <span class="nav-text">总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E5%85%A5"><span class="nav-number">4.1.</span> <span class="nav-text">插入</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E4%B8%8B%E6%A0%87"><span class="nav-number">4.1.1.</span> <span class="nav-text">1、下标</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E6%8F%92%E5%85%A5"><span class="nav-number">4.1.2.</span> <span class="nav-text">2、插入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E5%B0%BE%E6%8F%92%E6%B3%95"><span class="nav-number">4.1.3.</span> <span class="nav-text">3、尾插法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%AE%B9%E6%88%96%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">4.2.</span> <span class="nav-text">扩容或初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">4.2.1.</span> <span class="nav-text">1、初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E6%89%A9%E5%AE%B9"><span class="nav-number">4.2.2.</span> <span class="nav-text">2、扩容</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E7%9A%84%E6%98%93%E5%BF%98%E7%9A%84"><span class="nav-number">5.</span> <span class="nav-text">其他常用的易忘的</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="KebabShell"
      src="/images/hexo.jpg">
  <p class="site-author-name" itemprop="name">KebabShell</p>
  <div class="site-description" itemprop="description">纯个人记录</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">72</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">34</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/KebabShellGitHub" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;KebabShellGitHub" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:kebabshell@163.com" title="E-Mail → mailto:kebabshell@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/2837329130" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;2837329130" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kebabshellgithub.github.io/2020/12/09/HashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hexo.jpg">
      <meta itemprop="name" content="KebabShell">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="秋早亦朝">
      <meta itemprop="description" content="纯个人记录">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="HashMap | 秋早亦朝">
      <meta itemprop="description" content="HashMap 源码与总结">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          HashMap
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-12-09 23:00:46" itemprop="dateCreated datePublished" datetime="2020-12-09T23:00:46+00:00">2020-12-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
</div>

            <div class="post-description">HashMap 源码与总结</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>顾名思义，<code>HashMap</code> 就是以 <code>hash</code> 值为 <code>key</code> 的 <code>Map</code> 集合</p>
<p><code>HashMap</code> 是以 <strong>数组</strong> 作为容器的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure>

<p><code>Node</code> 是 <code>HashMap</code> 内部实现了 <code>Map.Entry</code> 的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    <span class="comment">// 链表要用到</span></span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.hash = hash;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 其他 balabala 鬼东西</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><code>HashMap</code> 就是以 hash 值为 key</p>
<p><code>put</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent, <span class="type">boolean</span> evict)</span></span><br></pre></td></tr></table></figure>

<p>而 <code>putVal</code> 第一个参数就是 hash 值，再看看 <code>hash</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">	<span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，如果 key 为 null，hash 值为 0；否则：</p>
<ul>
<li>hash 值为 <code>hashCode()</code> 做一次 16 位右位移异或</li>
</ul>
<p>为什么这样做，是因为 <strong>扰动函数</strong>，具体请看：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20733617">知乎传送门</a></p>
<p>下面提到的 <a href="#putVal">putVal</a> 也有讲</p>
<hr>
<h2 id="必识的变量"><a href="#必识的变量" class="headerlink" title="必识的变量"></a>必识的变量</h2><p><del><em>biss：最讨厌看这些静态常量了，每个字母都是大写</em></del></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 默认的容量</span></span><br><span class="line"><span class="comment">* default_initial_capacity</span></span><br><span class="line"><span class="comment">* 为什么是 16 ，且为什么推荐 2 的幂次方，看下面的 putVal 方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 最大容量上限</span></span><br><span class="line"><span class="comment">* maximun_capacity</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 在构造函数中未指定时使用的负载系数</span></span><br><span class="line"><span class="comment">* 负载因子</span></span><br><span class="line"><span class="comment">* default_load_factor</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 链表转换为树的阈值，超过这个长度的链表会被转换为红黑树</span></span><br><span class="line"><span class="comment">* treeify_threshold</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 当进行resize操作时，小于这个长度的树会被转换为链表</span></span><br><span class="line"><span class="comment">* untreeify_threshold</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 链表被转换成树形的最小容量，如果没有达到这个容量只会执行 resize 进行扩容</span></span><br><span class="line"><span class="comment">* 应该至少为4 * treeify_threshold，以避免大小调整和树化阈值之间发生冲突</span></span><br><span class="line"><span class="comment">* 链表超过 8 时，且数组长度大于等于 64，转为红黑树，如果数组长度小于 64，就进行扩容</span></span><br><span class="line"><span class="comment">* min_treeify_capacity</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存储元素的实体数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * set 数组，用于迭代元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存放元素的个数，但不等于数组的长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修改的次数</span></span><br><span class="line"><span class="comment"> * 与快速失败有关</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 临界值  如果实际大小超过临界值，就会进行扩容</span></span><br><span class="line"><span class="comment"> * threshold = 负载因子 * 容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加载因子、负载因子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h2><p> <code>resize</code> 方法不仅用来调整大小，还用来进行 <strong>初始化</strong> 配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果已经初始化</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果目前 table 的容量大于最大容量的上限，则不会进行扩容，并设置临界值为最大</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先对容量进行两倍扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">// 如果扩大两倍没超过上限，并且原来的容量大于等于16( DEFAULT_INITIAL_CAPACITY 16 )</span></span><br><span class="line">            <span class="comment">// 就会对临界值( threshold )也进行两倍扩容</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 如果没有初始化</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        <span class="comment">// 这个分支针对的指定初始化容量的构造方法</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 这个分支是针对默认构造函数的分支，对 newCap 和 newThr 进行赋值</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 临界值 = 容量 * 负载因子</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置 threshold</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 新数组</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 扩容完毕，需要把原来的元素逐一拷贝到新数组中去</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历原数组的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//将原来的置为 null，方便垃圾回收器进行回收</span></span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// 如果e.next为null，表示此链表是单节点</span></span><br><span class="line">                <span class="comment">// 直接根据 e.hash &amp; (newCap - 1) 得到新的位置进行赋值即可</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">// 如果是红黑树节点，则调用红黑树的方法</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 链表的复制</span></span><br><span class="line">                    <span class="comment">// 确定链表里面的元素在数组中的位置</span></span><br><span class="line">                    <span class="comment">// 元素有些不动，有些动</span></span><br><span class="line">                    <span class="comment">// 动的不是根据 hash 算法生成新的位置</span></span><br><span class="line">                    <span class="comment">// 而是采用 原始位置 + 原始容量 得到 新的位置</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 表示一条链表，该链表在新数组中的下标不变</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    <span class="comment">// 表示一条链表，该链表在新数组中的下标比原来增加 oldCap</span></span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 判断：元素的在数组中的位置是否需要移动</span></span><br><span class="line">                        <span class="comment">// (e.hash &amp; oldCap)结果为 0 就代表没有变化，否则就是有变化( 看下面 )</span></span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 这些是在新数组中位置不变的节点</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// 将符合条件的元素进行新的链表拼接</span></span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 这些是在新数组中位置 = 原位置 + oldCap 的节点</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// 和上面同理</span></span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 只要链表元素有下一个元素就循环进行拼接</span></span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 添加到新数组</span></span><br><span class="line">                    <span class="comment">// 位置不变</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 将链表的尾部的 next 置为空</span></span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        <span class="comment">// 直接将这个链插到新数组</span></span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 位置 + oldCap</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 将链表的尾部的 next 置为空</span></span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        <span class="comment">// + 原始容量</span></span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="扩容后链表元素的位置"><a href="#扩容后链表元素的位置" class="headerlink" title="扩容后链表元素的位置"></a>扩容后链表元素的位置</h3><p>直接判断 <code>(e.hash &amp; oldCap)</code>  ，结果为 0 就代表与之前的位置相比 没有变化，否则就是有变化</p>
<p>为什么要这样来决定？</p>
<p>我们知道( 如果不知道，看下面的 <a href="#putVal">putVal</a> )，<code>(n - 1) &amp; hash</code> 是元素在数组的位置( n 是容量大小 )</p>
<p>假设 <code>oldCap</code> 为 16，也就是 2^4</p>
<p>n - 1 &#x3D; 15，即 0000 0000 …… 1111</p>
<p>而 &amp; hash 就是取 hash 的低 4 位，设为 xxxx</p>
<p>此时数组扩容是2倍，也就是 2 * oldCap &#x3D; 32 &#x3D; 2^5，&amp; hash 后就是取 hash 的低 5 位</p>
<p>对于低 5 位，对于同一个元素，无非就是</p>
<ul>
<li>1xxxx</li>
<li>0xxxx</li>
</ul>
<p>0xxxx 和 没扩容前的低 4 位一样</p>
<p>1xxxx &#x3D; 原来的低 4 位 + oldCap</p>
<p>但是怎么才能知道是 0 还是 1？</p>
<p>直接 <code>(e.hash &amp; oldCap)</code>  即 hash &amp; 0000 0000 …… <strong>1 0000</strong> 不就行了！！</p>
<p>如果 <code>(e.hash &amp; oldCap) = 0</code>  那就是说元素在新数组的位置还是之前的，不变；</p>
<p>如果 <code>(e.hash &amp; oldCap) = 1</code>  那就是说元素在新数组的位置 &#x3D; <strong>原来的位置 + oldCap</strong></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000015812438">参考文章</a></p>
</blockquote>
<hr>
<h2 id="putVal"><a href="#putVal" class="headerlink" title="putVal"></a>putVal</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数 onlyIfAbsent 表示是否替换原值</span></span><br><span class="line"><span class="comment">// true: 不替换，false: 替换</span></span><br><span class="line"><span class="comment">// 参数 evict 我们可以忽略它，它主要用来区别通过 put 添加还是创建时初始化数据的</span></span><br><span class="line"><span class="comment">// 如果为 false，该 table 处于创建阶段</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">// 如果 table 数组为空 或 长度为 0，则对其进行初始化，分配内存空间</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// resize()不仅用来调整大小，还用来进行初始化配置</span></span><br><span class="line">        <span class="comment">// 这里就用到 resize 初始化</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当 put 的 key 在数组中不存在时，直接 new 一个 Node 元素放入</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// (n - 1) &amp; hash 就是把 hash &amp; ( 数组长度 - 1 )</span></span><br><span class="line">        <span class="comment">// 为什么要 n - 1 呢，这里正好解释了为什么 HashMap 的数组长度要取 2 的整次幂</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// n - 1 正好相对于做了一个&quot;低位掩码&quot;</span></span><br><span class="line">        <span class="comment">// &amp; 操作的结果就是散列值的高位全部归零</span></span><br><span class="line">        <span class="comment">// 只保留低位值，用来做数组下标访问</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 以初始长度 16 为例，16 - 1 = 15</span></span><br><span class="line">        <span class="comment">// 二进制就是 0000 …… 1111</span></span><br><span class="line">        <span class="comment">// 和 hash &amp; 后，就是取低 4 位</span></span><br><span class="line">        <span class="comment">//   0000 0000 0000 0000 0000 1111</span></span><br><span class="line">        <span class="comment">// &amp; 0000 0001 0100 1010 1010 0101</span></span><br><span class="line">        <span class="comment">// = 0000 0000 0000 0000 0000 0101 高位归零，只保留末四位</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 但是只取末四位碰撞也很严重</span></span><br><span class="line">        <span class="comment">// 所有就有了 hash(Object key) 这个扰动函数，putVal 的参数 hash 要先搞扰动</span></span><br><span class="line">        <span class="comment">// 再进来 hash(Object key)</span></span><br><span class="line">        <span class="comment">// hashCode() 获取哈希值 h，然后 h &gt;&gt;&gt; 16，右位移 16 位，正好是 32 位一半</span></span><br><span class="line">        <span class="comment">// 然后把自己的高半区和低半区异或(^)</span></span><br><span class="line">        <span class="comment">// ( 为了加大低位的随机性，而且混合后低位掺杂了高位的部分特征，这样高位的信息变相保留了下来 )</span></span><br><span class="line">           </span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 简单版</span></span><br><span class="line">        <span class="comment">// 先通过 hashcode 拿到最初的 hash 值，也就是 32 位的内存地址</span></span><br><span class="line">        <span class="comment">// 然后高 16 位右移和原来的 hash 异或( 两个不同就为真 )</span></span><br><span class="line">        <span class="comment">// 这时候低 16 位就保留了高低位的信息</span></span><br><span class="line">        <span class="comment">// 然后再和( 数组大小 - 1 )与( &amp; )，拿到低位</span></span><br><span class="line">        <span class="comment">// 而数组大小建议是 2 的幂次方，这样减 1 后低位就是 000...1111，和已经扰动的 hash 值与( &amp; )一下就拿到低位</span></span><br><span class="line">        <span class="comment">// 这样这个低位就有很大的随机性，这个低位来充当数组下标，能更有效的避免哈希碰撞</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里就是看下在 hash 位置有没有元素，实际位置是 hash % (length - 1)</span></span><br><span class="line">        <span class="comment">// 将元素直接插进去</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 如果元素在集合中已存在</span></span><br><span class="line">        <span class="comment">// 这时就需要链表或红黑树了</span></span><br><span class="line">        <span class="comment">// e 是用来查看是不是待插入的元素已经有了，有就替换</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// p 是存储在当前位置的元素</span></span><br><span class="line">        <span class="comment">// 如果 tab[(n - 1) &amp; hash] 位置的第一个元素的 key 和要保存的 key 相等</span></span><br><span class="line">        <span class="comment">// 这说明目的是修改值</span></span><br><span class="line">        <span class="comment">// 将 p 的值赋给 e</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 如果是红黑树节点，则调用其put方法</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 把节点添加到树中</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 不是替换第一个节点，也不是红黑树节点，那就是链表了</span></span><br><span class="line">        <span class="comment">// 循环每一个元素</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这时候就是链表结构了，使用尾插法!!!</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 如果找找找，也没有找到一样的 key，且 p 没有下一个了</span></span><br><span class="line">                <span class="comment">// 就直接 new</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 如果超过树的阈值，就要变成红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        <span class="comment">// 由于初始即为 p.next，所以当插入第 8 个元素才会树化</span></span><br><span class="line">                        <span class="comment">// -1 for 1st 如果链表的长度超过 8，则进行红黑树进行转换。</span></span><br><span class="line">                        <span class="comment">// 1.8后追加：链表查询的复杂度是 O(n)，而红黑树是 O(log(n))，</span></span><br><span class="line">                        <span class="comment">// 但是如果 hash 不均匀会极大的影响性能</span></span><br><span class="line">                        <span class="comment">// 此方法里面会判断，如果数组长度大于等于 64，转为红黑树，</span></span><br><span class="line">                        <span class="comment">// 如果数组长度小于 64，就进行扩容 resize</span></span><br><span class="line">                        treeifyBin(tab, hash); </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 找到了对应元素，就可以停止了</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">//此时 e 就是找到的相同 key 的，要替换的节点</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 继续向后循环</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时 e 就是找到的相同 key 的，要替换的节点</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 原值</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="comment">// 如果 onlyIfAbsent 为 false，或者原值为 null，就是要替换</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                <span class="comment">// 改</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">// afterNodeAccess 默认为空实现，允许我们修改完成后做一些操作</span></span><br><span class="line">            <span class="comment">// 它由 LinkedHashMap 的实现，并调用</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">// 返回，这里是返回已经更新的值，这是引用</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 操作数 + 1</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 如果 size 大于扩容阀值 threshold，则进行扩容操作</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 由 LinkedHashMap 的实现，并调用</span></span><br><span class="line">    <span class="comment">// 作用：在执行一次插入操作都会执行的操作</span></span><br><span class="line">    <span class="comment">// 主要就是对 LRU 算法的支持</span></span><br><span class="line">    <span class="comment">// 是否移动最早的元素。、但是 LinkedHashMap 中总是返回 false，所以在这里没什么用</span></span><br><span class="line">    <span class="comment">// 回调移除最早放入 Map 的对象</span></span><br><span class="line">    <span class="comment">// 默认也是空实现，允许我们插入完成后做一些操作</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="尾插法"><a href="#尾插法" class="headerlink" title="尾插法"></a>尾插法</h3><p>1.8 之前插入元素是使用头插法，可能觉得新来的被访问的可能性高</p>
<p>但是 1.8 之后却使用尾插法</p>
<p>简单来说：头插法，<strong>多线程</strong> 插入时，会在扩容的时候造成 <code>Infinite Loop</code> ，即 A 指向 B，B 指向 A</p>
<p>具体是为什么请看：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Ho528528/article/details/103903998">参考文章</a></p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>首先 HashMap 是实现了 Map 接口的，所以是它的每个元素都是以键值对的形式存放</p>
<p>而这个键值对 是实现了 Map 接口定义的 Node 类，它的成员变量有 hash、key、value，还有下一个节点 next</p>
<p>而存放这些键值对元素的底层就是 Node 数组</p>
<p>当第一次发生插入时，首先是初始化，即使用 resize 方法</p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><h4 id="1、下标"><a href="#1、下标" class="headerlink" title="1、下标"></a>1、下标</h4><p>而插入的时候，数组下标是 key 的 hash 值 &amp; ( 数组长度 - 1 )</p>
<p>这个 hash 值是经过扰动得来的，先通过 hashcode 拿到最初的 hash 值，也就是 32 位的内存地址</p>
<p>然后高 16 位右移和原来的 hash 异或^( 两个不同就为真 )</p>
<p>这时候低 16 位就保留了高低位的信息</p>
<p>然后再和( 数组大小 - 1 )与( &amp; )，拿到低位作为数组下标</p>
<p>而数组大小建议是 2 的幂次方，这样减 1 后低位就是 000…1111，和已经扰动的 hash 值与( &amp; )一下就拿到低位</p>
<p>这样这个低位就有很大的随机性，这个低位来充当数组下标，能更有效的避免哈希碰撞</p>
<h4 id="2、插入"><a href="#2、插入" class="headerlink" title="2、插入"></a>2、插入</h4><p>如果这个下标没有元素，就直接赋值</p>
<p>如果有元素</p>
<ul>
<li><p>且 key 相同而且 hash 相同，就替换嘛</p>
</li>
<li><p>如果 key 不同或者 hash 不同，那就类型判断( instanceof )，看看原来这个位置的节点是不是红黑树( TreeNode )</p>
<ul>
<li>如果是红黑树就执行红黑树的插入</li>
<li>如果不是，那就是执行链表的插入<ul>
<li>如果 next 为空，直接new节点( newNode方法 )，<strong>尾插法( jdk 1.8 )</strong><ul>
<li>而且它有一个计数的变量( binCount )，如果个数超过了设置的红黑树阈值( TREEIFY_THRESHOLD )( 默认 8 )，就执行链表转红黑树方法( treeifyBin )</li>
</ul>
</li>
<li>如果 next 不为空<ul>
<li>但 key 不同或者 hash 不同，就继续迭代链表</li>
<li>且 hash 相同，key 也相同，这时候就看 put 方法的参数有没有说如果遇到 key 和 hash 一样的，是否要保留原值，再进行操作</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>插入结束后，会自增 map 的 size，如果实际大小超过临界值( threshold )，就会进行扩容( threshold &#x3D; 负载因子 * 容量 )，执行 resize 方法</p>
<h4 id="3、尾插法"><a href="#3、尾插法" class="headerlink" title="3、尾插法"></a>3、尾插法</h4><p>1.8 之前插入元素是使用头插法，可能觉得新来的被访问的可能性高。</p>
<p>但是1.8 及以后却使用尾插法。</p>
<p>简单来说：头插法，<strong>多线程</strong> 插入时，会在扩容的时候造成 <code>Infinite Loop( 无限循环、死循环 )</code> ，形成 <strong>环形链表</strong>，即 A 指向 B，B 指向 A</p>
<h3 id="扩容或初始化"><a href="#扩容或初始化" class="headerlink" title="扩容或初始化"></a>扩容或初始化</h3><h4 id="1、初始化"><a href="#1、初始化" class="headerlink" title="1、初始化"></a>1、初始化</h4><p>如果是第一次插入，那么需要进行初始化，而初始化是在 resize 方法里面</p>
<p>在 resize 方法里面，因为 HashMap new 的时候只是初始化了负载因子，是 0.75f，而 resize 方法会对容量和临界值( threshold )赋值</p>
<p>如果在构造函数里已经有具体的容量参数，就直接用</p>
<p>如果没有，就用默认的</p>
<h4 id="2、扩容"><a href="#2、扩容" class="headerlink" title="2、扩容"></a>2、扩容</h4><p>如果已经初始化</p>
<p>如果目前现在的的容量大于最大容量的上限( MAXIMUM_CAPACITY )，则不会进行扩容，并且设置临界值( threshold )为最大( Integer.MAX_VALUE )</p>
<p>如果现在的容量没到达上限，就会对容量进行 <strong>两倍扩容</strong>( &lt;&lt; 1 )</p>
<ul>
<li>而且再扩大两倍还没超过上限，并且原来的容量大于默认的容量( DEFAULT_INITIAL_CAPACITY 16 )<ul>
<li>就会对临界值( threshold )也进行 <strong>两倍扩容</strong>( &lt;&lt; 1 )</li>
</ul>
</li>
</ul>
<p>完成后，再进行元素的重新放置</p>
<p>它会开一个新容量的数组，按照老数组的下标来遍历，把元素都拷进去</p>
<ul>
<li>如果元素 next 为 null，表示此元素是单个的，直接根据 hash &amp; ( 容量 - 1 ) 得到新的位置进行赋值</li>
<li>如果元素 next 不为 null，再判断是不是红黑树节点<ul>
<li>如果是，就按红黑树转</li>
<li>如果不是，那就是链表了<ul>
<li>新的链表头的下标不是根据 hash &amp; ( 容量 - 1 ) 得到新的位置</li>
<li>而是根据判断( e.hash &amp; oldCap )是不是等于 0，来决定是 采用( 原始位置 + 原始容量 )得到 新的位置，还是位置不变<ul>
<li>它会维护两个链表，一个存着位置不变的元素链，一个存着位置为( 原始位置 + 原始容量 )的元素链</li>
<li>至于为什么根据( e.hash &amp; oldCap )来判断<ul>
<li>看上面的 <a href="#%E6%89%A9%E5%AE%B9%E5%90%8E%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0%E7%9A%84%E4%BD%8D%E7%BD%AE">扩容后链表元素的位置</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="其他常用的易忘的"><a href="#其他常用的易忘的" class="headerlink" title="其他常用的易忘的"></a>其他常用的易忘的</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? defaultValue : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"># Java</a>
              <a href="/tags/%E9%9B%86%E5%90%88/" rel="tag"># 集合</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/12/09/Java-%E9%9B%86%E5%90%88%E7%AE%80%E8%BF%B0/" rel="prev" title="Java 集合简述">
                  <i class="fa fa-chevron-left"></i> Java 集合简述
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/12/12/Kafka/" rel="next" title="Kafka">
                  Kafka <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">KebabShell</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  <script src="/js/third-party/pace.js"></script>

  





</body>
</html>
